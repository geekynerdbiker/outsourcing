#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>

#define MATRIX_SIZE 1000
int A[MATRIX_SIZE][MATRIX_SIZE], B[MATRIX_SIZE][MATRIX_SIZE], C[MATRIX_SIZE][MATRIX_SIZE];
int num_threads_or_processes;

char* files[] = {"file1.txt", "file2.txt", "file3.txt", "file4.txt"};
int num_files = sizeof(files) / sizeof(files[0]);

void initialize_matrices() {
    srand(time(NULL));
    for (int i = 0; i < MATRIX_SIZE; i++) {
        for (int j = 0; j < MATRIX_SIZE; j++) {
            A[i][j] = rand() % 10;
            B[i][j] = rand() % 10;
        }
    }
}

void reset_result_matrix() {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        for (int j = 0; j < MATRIX_SIZE; j++) {
            C[i][j] = 0;
        }
    }
}

void* multiply_thread(void* arg) {
    int thread_id = *(int*)arg;
    int rows_per_thread = MATRIX_SIZE / num_threads_or_processes;
    int start = thread_id * rows_per_thread;
    int end = (thread_id == num_threads_or_processes - 1) ? MATRIX_SIZE : start + rows_per_thread;

    for (int i = start; i < end; i++) {
        for (int j = 0; j < MATRIX_SIZE; j++) {
            for (int k = 0; k < MATRIX_SIZE; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return NULL;
}

void multiply_process(int process_id) {
    int rows_per_process = MATRIX_SIZE / num_threads_or_processes;
    int start = process_id * rows_per_process;
    int end = (process_id == num_threads_or_processes - 1) ? MATRIX_SIZE : start + rows_per_process;

    for (int i = start; i < end; i++) {
        for (int j = 0; j < MATRIX_SIZE; j++) {
            for (int k = 0; k < MATRIX_SIZE; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

void multiply_with_threads() {
    for (num_threads_or_processes = 1; num_threads_or_processes <= 16; num_threads_or_processes *= 2) {
        pthread_t threads[num_threads_or_processes];
        int thread_ids[num_threads_or_processes];
        struct timespec start, end;

        reset_result_matrix();
        clock_gettime(CLOCK_MONOTONIC, &start);

        for (int i = 0; i < num_threads_or_processes; i++) {
            thread_ids[i] = i;
            pthread_create(&threads[i], NULL, multiply_thread, &thread_ids[i]);
        }

        for (int i = 0; i < num_threads_or_processes; i++) {
            pthread_join(threads[i], NULL);
        }

        clock_gettime(CLOCK_MONOTONIC, &end);
        double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        printf("\t\tThreads: %d, Time: %f seconds\n", num_threads_or_processes, elapsed);
    }
}

void multiply_with_processes() {
    for (num_threads_or_processes = 1; num_threads_or_processes <= 16; num_threads_or_processes *= 2) {
        struct timespec start, end;

        reset_result_matrix();
        clock_gettime(CLOCK_MONOTONIC, &start);

        for (int i = 0; i < num_threads_or_processes; i++) {
            pid_t pid = fork();
            if (pid == 0) {
                multiply_process(i);
                exit(0);
            }
        }

        for (int i = 0; i < num_threads_or_processes; i++) {
            wait(NULL);
        }

        clock_gettime(CLOCK_MONOTONIC, &end);
        double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        printf("\t\tProcesses: %d, Time: %f seconds\n", num_threads_or_processes, elapsed);
    }
}

void* compress_thread(void* arg) {
    int thread_id = *(int*)arg;
    int files_per_thread = num_files / num_threads_or_processes;
    int start = thread_id * files_per_thread;
    int end = (thread_id == num_threads_or_processes - 1) ? num_files : start + files_per_thread;

    char copy_command[50];
    char gzip_command[50];
    for (int i = start; i < end; i++) {
        snprintf(copy_command, sizeof(copy_command), "cp %s %s_copy", files[i], files[i]);
        system(copy_command);

        snprintf(gzip_command, sizeof(gzip_command), "gzip %s_copy", files[i]);
        system(gzip_command);
    }
    return NULL;
}

void compress_process(int process_id) {
    int files_per_process = num_files / num_threads_or_processes;
    int start = process_id * files_per_process;
    int end = (process_id == num_threads_or_processes - 1) ? num_files : start + files_per_process;

    char copy_command[50];
    char gzip_command[50];
    for (int i = start; i < end; i++) {
        snprintf(copy_command, sizeof(copy_command), "cp %s %s_copy", files[i], files[i]);
        system(copy_command);

        snprintf(gzip_command, sizeof(gzip_command), "gzip %s_copy", files[i]);
        system(gzip_command);
    }
}

void compress_with_threads() {
    for (num_threads_or_processes = 1; num_threads_or_processes <= 16; num_threads_or_processes *= 2) {
        pthread_t threads[num_threads_or_processes];
        int thread_ids[num_threads_or_processes];
        struct timespec start, end;

        clock_gettime(CLOCK_MONOTONIC, &start);

        for (int i = 0; i < num_threads_or_processes; i++) {
            thread_ids[i] = i;
            pthread_create(&threads[i], NULL, compress_thread, &thread_ids[i]);
        }

        for (int i = 0; i < num_threads_or_processes; i++) {
            pthread_join(threads[i], NULL);
        }

        clock_gettime(CLOCK_MONOTONIC, &end);
        double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        printf("\t\tThreads: %d, Time: %f seconds\n", num_threads_or_processes, elapsed);
    }
}

void compress_with_processes() {
    for (num_threads_or_processes = 1; num_threads_or_processes <= 16; num_threads_or_processes *= 2) {
        struct timespec start, end;

        clock_gettime(CLOCK_MONOTONIC, &start);

        for (int i = 0; i < num_threads_or_processes; i++) {
            pid_t pid = fork();
            if (pid == 0) {
                compress_process(i);
                exit(0);
            }
        }

        for (int i = 0; i < num_threads_or_processes; i++) {
            wait(NULL);
        }

        clock_gettime(CLOCK_MONOTONIC, &end);
        double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        printf("\t\tProcesses: %d, Time: %f seconds\n", num_threads_or_processes, elapsed);
    }
}

int main() {
    initialize_matrices();

    printf("[ Data Parallelism ]\n");
    printf("\tRunning multiply with threads...\n");
    multiply_with_threads();
    printf("\tRunning multiply with processes...\n");
    multiply_with_processes();

    printf("[ Task Parallelism ]\n");
    printf("\tRunning compress with threads...\n");
    compress_with_threads();
    printf("\tRunning compress with processes...\n");
    compress_with_processes();

    return 0;
}


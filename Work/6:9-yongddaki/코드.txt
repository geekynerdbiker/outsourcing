#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#define _CRT_SECURE_NO_WARNINGS
#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 600
#define INF 9999
#define SIZE 20

typedef struct element {
	char name[SIZE];
}element;

typedef struct GraphType {
	element station[MAX_VERTICES]; // 역이름
	int n; // 정점의 개수
	int weight[MAX_VERTICES][MAX_VERTICES]; // 가중치
}GraphType;

int distance[MAX_VERTICES]; // 
int found[MAX_VERTICES]; // 방문 여부 저장

void input_station(GraphType* g)
{
	FILE* fp = NULL;
	fp = fopen_s(&fp, "1호선.csv", "r");
	char str_tmp[1024];

	if (fp == NULL){
		printf("fail to read file");
		return 0;
	}

	int i = 0;
	while (!feof(fp)) {
		fgets(str_tmp, 1024, fp);
		printf("%s", str_tmp);
	}

	fclose(fp);
}


int choose(int distance[], int n, int found[])
{
	int i, min, minpos;
	min = INT_MAX;
	minpos = -1;
	for (i = 0; i < n; i++) { // 최소값을 찾기 위한 반복문
		if (distance[i] < min && !found[i]) //만약 현재 방문하지 않는 노드 중 i로까지의 거리가 현재 최소값 min보다 작다면
		{
			min = distance[i]; // 최소 거리인 i로 까지의 거리를 min르호 설정
			minpos = i; // 최소값을 가진 노드의 인덱스 i를 minpos에 저장
		}
	}
	return minpos; // 최소 거리 노드 인덱스인 i를 반환
}

void shortest_path(GraphType* g, int start)
{
	int i, u, w;

	for (i = 0; i < g->n; i++) // 초기화 하기 위한 반복문
	{
		distance[i] = g->weight[start][i]; // 시작 정점 start를 기준으로 했을때 가중치로 distance 배열을 초기화
		found[i] = FALSE; // 시작 전 방문 여부를 FALSE로 지정
	}
	found[start] = TRUE; // 시작 정점을 방문 표시
	distance[start] = 0; // 시작 정점부터 시작 정점까지의 거리 == 0

	for (i = 0; i < g->n - 1; i++) // 시작 정점을 설정 했으므로 n-1만큼 반복
	{
		print_status(g); // 그래프 최단 경로 출력
		u = choose(distance, g->n, found); // 방문되지 않은 distance의 인덱스중 최소값의 인덱스를 u로 지정
		found[u] = TRUE; // 현재 distance배열에서 최소갑 인덱스인 u를 정점으로 선택, 방문되었다고 표시


		for (w = 0; w < g->n; w++) // 가중치가 가장 적은 값을 가진 정점을 집합 S에 추가한 뒤 계속하여 새롭게 발견되는 최소 가중치 정보를 수정하기 위한 반복문
			if (!found[w]) // 아직 선택 되지 않은 정점일때
				if (distance[u] + g->weight[u][w] < distance[w]) // 만약 u까지의 최단 거이롸 u에서 w의 거리를 합친 거리가 기존의 기준점에서 w까지의 거리보다 가깝다면
					distance[w] = distance[u] + g->weight[u][w]; // 그 값으로 정보를 수정


	}
}

int main(void)
{
	GraphType* g = (GraphType*)malloc(sizeof(GraphType));
	input_station(g);
	free(g);
}
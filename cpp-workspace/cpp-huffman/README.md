[ 각 파일 역할 설명 ]
Node.h      : 1번 문제에서 주어진 Node 클래스 헤더
Node.cpp    : Node 클래스 함수 정의
Heap.h      : Heap 클래스 헤더
Heap.cpp    : Heap 클래스 함수 정의
main1.cpp   : 1번 문제
main2.cpp   : 2번 문제
main3.cpp   : 3번 문제

[ 문제별 컴파일 및 실행 커멘드 ]
VS Studio   : 프로젝트 생성 후 실행 할 main 파일을 제외하고 다른 main 파일들 주석 처리 후 실행.
GCC         : Makefile을 이용하여 컴파일. 실행은 각각 main1, main2, main3

[ 문제 풀이에 대한 간략한 설명 ]
1. 최소 힙 구현. 인덱스로 구성된 Complete Bianry Tree이며, 최상위 노드는 가장 작은 값을 가지고, 부모 노드는 항상 자식보다 작거나 같음.

2. 허프만 알고리즘. 빈도가 작은 순으로 정렬하고, 맨 앞 두 개의 노드를 꺼냄. 꺼낸 두 개의 노드로 부모 노드를 만듦(빈도가 작은 노드가 왼쪽 자식, 빈도가 같으면 사전 순서로 빠른 노드가 왼쪽 자식). 합쳐진 부모 노드를 다시 힙에 Push. 빈도순으로 정렬. (반복)

주의할 점은 합쳐진 노드와 리프 노드를 합할 때, 만약 두 노드의 빈도가 같을 때, 리프 노드가 무조건 왼쪽 자식이 됨. 둘 다 합쳐진 노드라면, 자식 리프 노드 중 가장 왼쪽에 있는 리프 노드를 서로 비교하여 사전순으로 빠른 노드가 왼쪽 자식이 됨.

고려할 점은 합쳐서 노드를 만들때, 노드의 데이터를 NULL이 아닌 합쳐지는 노드의 데이터들 중 사전순으로 먼저 오는 데이터를 취함.

3. 역 허프만 알고리즘. table.txt 파일에서 각 문자와 해당 Huffman 코드를 읽어 맵핑 테이블을 생성. code.txt 파일에서 Huffman 인코딩된 이진 문자열을 읽어옴. 이진 문자열을 한 비트씩 읽으면서 currentCode에 누적.
누적된 currentCode가 코드 테이블에 존재하면 해당 문자를 decoded에 추가하고 currentCode를 초기화. 이후 복호화된 원본 문자열 출력. 프리픽스 코드이므로 부분 문자열이 존재할 수 없어 복호화가 쉬움.